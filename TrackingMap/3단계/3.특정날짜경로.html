<!-- *** Info ***
서버코드 : oneday_course_server.js
특정날짜선택시, 파랑색경로로 표시
이는 psql에서 water_quality에서 위치데이터만 불러옴
-->

<style>
    #ecobot_map {
        width: 100%;
        height: 90%;
    }
  </style>
  <div id="ecobot_map"></div>
  <div style="margin: 10px;">
    <label for="date-picker">날짜 선택:</label>
    <input type="date" id="date-picker" value="2023-10-31">
    <button onclick="fetchDataBasedOnDate()">데이터 가져오기</button>
  </div>
  
  <script>
  
    var map;
    var isInitialLocationSet = false;
    var robotPathCoordinates = [];
    var currentRobotMarker = null;
    var orangeMarkers = [];
    var paths = [];
    const API_BASE = "http://125.136.64.124:24003";
    const ROBOT_ID = 'robot00005'; // 동적로봇 id설정, 필요에따라 이 부분만 변경하기
    const ecobot_ID = "ecobot00005"; 
    const update_func = 10000; // 10초마다 한번씩 해당함수 반복호출
    const lat = 35.6284; // 위도
    const lng = 127.1435; // 경도
  
    function initMap() {
        // 로봇에따라 위도,경도 변경
        initializeMapAtLocation(new google.maps.LatLng(lat, lng)); 
        ws_all_tracking_map = new WebSocket('ws://125.136.64.124:24101');
        ws_all_tracking_map.onmessage = function (event) {
            const msg = JSON.parse(event.data);
  
            if (msg.topic === "/"+ecobot_ID+"/gps_location") {
                const gpsMessage = JSON.parse(msg.message);
                console.log("Received GPS Data:", gpsMessage);
  
                const gpsData = {
                    lat: gpsMessage.latitude,
                    lng: gpsMessage.longitude
                };
                updateRobotMarkersAndPath(gpsData);
            }
        };
  
        fetchGps20DataForRobot(ROBOT_ID);  // 여기서 GPS 20 데이터를 가져옵니다.
  
        // 10초마다 fetchGps20DataForRobot 함수를 호출합니다.
        setInterval(function() {
            fetchGps20DataForRobot(ROBOT_ID);
        }, update_func); // 10초마다 해당함수 반복호출
    }
  
    function fetchGps20DataForRobot(robotID) {
      fetch(API_BASE + "/get-gps20data-for-robot/" + robotID)
          .then(response => response.json())
          .then(data => {
              // 기존의 마커와 경로를 삭제합니다.
              orangeMarkers.forEach(marker => marker.setMap(null));
              orangeMarkers = [];
              paths.forEach(path => path.setMap(null));
              paths = [];
  
              // 여기서 robotPathCoordinates를 초기화하지 않고, selectedDatePathCoordinates 데이터를 유지합니다.
              if (selectedDatePathCoordinates.length === 0) {
                  robotPathCoordinates = [];
              }
  
              data.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt)); // 데이터를 시간 순서대로 정렬합니다.
  
              data.forEach(gpsData => {
                  const loc = new google.maps.LatLng(gpsData.lat, gpsData.lng);
                  robotPathCoordinates.push(loc);
                  const newMarker = placeOrangeMarker(loc);  // 주황색 마커를 추가하는 함수
                  orangeMarkers.push(newMarker);
              });
  
              // 선택된 날짜에 대한 경로가 없을 때만 경로를 다시 그립니다.
              if (selectedDatePathCoordinates.length === 0) {
                  redrawPathBetweenMarkers();  // 마커 사이에 경로를 다시 그립니다.
              }
          });
    }
  
    function redrawPathBetweenMarkers() {
        // 기존의 경로를 제거합니다.
        if (paths.length > 0) {
            for (const path of paths) {
                path.setMap(null);
            }
            paths = [];
        }
        
        const path = new google.maps.Polyline({
            path: robotPathCoordinates,
            geodesic: true,
            strokeColor: '#FFA500',
            strokeOpacity: 1.0,
            strokeWeight: 2,
            map: map
        });
        paths.push(path);
    }
    
    function placeOrangeMarker(location) {
        const marker = new google.maps.Marker({
            position: location,
            map: map,
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 2,
                fillColor: '#FFA500',
                fillOpacity: 1,
                strokeColor: '#FFA500',
                strokeWeight: 2
            }
        });
        return marker;
    }
    
    function drawPathBetweenMarkers() {
        // 기존에 그려진 경로를 모두 제거합니다.
        for (const path of paths) {
            path.setMap(null);
        }
        paths = [];
        
        const path = new google.maps.Polyline({
            path: robotPathCoordinates,
            geodesic: true,
            strokeColor: '#FFA500',
            strokeOpacity: 1.0,
            strokeWeight: 2,
            map: map
        });
        paths.push(path);
    }
  
    function updateRobotMarkersAndPath(gpsData) {
        if (typeof gpsData.lat === "number" && typeof gpsData.lng === "number") {
            const latestLocation = new google.maps.LatLng(gpsData.lat, gpsData.lng);
        
            if (!isInitialLocationSet) {
                initializeMapAtLocation(latestLocation);
                isInitialLocationSet = true;
                return;
            }
        
            placeRobotMarker(latestLocation);
            robotPathCoordinates.push(latestLocation);
        } else {
            console.error("Invalid GPS data received:", gpsData);
        }
    }
  
    function placeRobotMarker(location) {
        if (currentRobotMarker) {
            currentRobotMarker.setMap(null);
        }
  
        currentRobotMarker = new google.maps.Marker({
            position: location,
            map: map,
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 2,
                strokeColor: '#ffff00'
            }
        });
    }
  
    function initializeMapAtLocation(location) {
        const mapElementId = "ecobot_map"; // 동적 요소 ID 생성
        map = new google.maps.Map(document.getElementById(mapElementId), {
            zoom: 15,
            center: location,
            disableDefaultUI: true,
            mapTypeId: 'satellite'
        });
    }
  
    // < psql데이터가져와 특정날짜의 경로찍기 > : oneday_course_server.js와 연결
    var selectedDatePathCoordinates = []; // 특정 날짜에 대한 경로 데이터를 저장할 변수
    var bluePath = null;
    
    function fetchDataBasedOnDate() {
        const date = document.getElementById('date-picker').value;
        fetch(`http://125.136.64.124:24003/get-water-quality?date=${date}`, {
            method: 'GET',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': 'http://125.136.64.124:23000',
            },
        })
        .then(response => response.json())
        .then(data => {
            console.log(data);
            if (Array.isArray(data) && data.length > 0) {
                // 기존의 특정 날짜 경로 데이터를 삭제
                selectedDatePathCoordinates = [];
    
                // 서버로부터 받아온 데이터를 필터링
                const gpsCoordinates = data
                    .map(d => ({
                        lat: parseFloat(d.latitude),
                        lng: parseFloat(d.longitude)
                    }))
                    .filter(coord => !isNaN(coord.lat) && !isNaN(coord.lng)); // 유효하지 않은 값을 제거
    
                // 필터링된 데이터를 사용하여 파랑색 경로를 그린다.
                drawBluePath(gpsCoordinates);
            }
        })
        .catch(error => console.error('Error fetching data:', error));
    }
  
    function drawBluePath(coordinates) {
        // 기존의 파랑색 경로를 제거
        if (bluePath) {
            bluePath.setMap(null);
        }
    
        // 새로운 파랑색 경로를 그린다.
        bluePath = new google.maps.Polyline({
            path: coordinates,
            geodesic: true,
            strokeColor: '#0000FF',  // 파랑색
            strokeOpacity: 1.0,
            strokeWeight: 2,
            map: map
        });
    }
    
  </script>
  <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBsKGG9iHYhgK1gOtqS9vfPnVX61O3tcvQ&callback=initMap"></script>